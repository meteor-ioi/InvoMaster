# 语义原子化 (Semantic Atomization) 定位系统设计文档

## 1. 背景与目标
在处理 OCR 识别的图像文档时，传统的“按单词”或“按行”切分往往面临两个痛点：
1.  **切分粒度不一致**：OCR 模型通常返回整行文本，导致用户无法精确选中单个词或汉字。
2.  **空格丢失/粘连**：在机械合并字符时，单词间的空格容易丢失（如 `Billing Address` 变成 `BillingAddress`），或出现不必要的空格（如 `S h i p p e d`）。

**语义原子化**系统旨在通过结合浏览器原生的语义解析与几何启发式算法，提供精准、鲁棒且符合排版常识的文本定位体验。

---

## 2. 核心原理

### 2.1 语义原子生成 (Atomization)
不再将 OCR 结果视为不可分割的字符串，而是利用 **`Intl.Segmenter`** API 将其拆解为最小的“语义原子”序列。
-   **Intl.Segmenter**：浏览器内置的高性能本地化分词器，原生支持中英文混排的精确切词。
    - **中文支持示例**：
        - 输入：`"发货地址：上海市"`
        - `granularity: 'word'` -> `["发货", "地址", "：", "上海市"]`
        - `granularity: 'grapheme'` -> `["发", "货", "地", "址", "：", "上", "海", "市"]`
-   **原子分类**：每个原子被标记为 `Word`（单词/词组）、`Space`（空白字符）或 `Punct`（标点）。
-   **几何映射**：系统根据原子在原字符串中的位置，按比例为其分配物理坐标边界（Bounding Box）。

### 2.2 动态聚合逻辑 (Dynamic Grouping)
系统根据用户选择的精度（字、词、行）动态合并原子：

| 粒度 | 聚合策略 | 表现 |
| :--- | :--- | :--- |
| **字 (Char)** | 不聚合 | 每个 grapheme（字位）独立感应。 |
| **词 (Word)** | 语义合并 | 合并连续的字母或汉字形成的语义块，排除独立的空白块。 |
| **行 (Line)** | 物理+语义合并 | 合并同一水平线上且间距合理的原子序列。 |

---

## 3. 关键特性

### 3.1 几何智能空格 (Smart Geometric Spaces)
为了保证文本锚点的鲁棒性，系统在聚合原子时会进行几何间距检测：
-   如果两个原子间的物理间距超过阈（通常为行高的 12%），即使原始 OCR 结果中没有空格，系统也会在生成的锚点文本中**自动补偿一个空格**。
-   这解决了 OCR 常见的“视觉上有间距但结果无空格”的问题，确保了 `Shipped From` 等词组的完整性。

### 3.2 自动分栏保护 (Column Protection)
在【行】模式下，如果同一行内两段文字的间距过大（超过行高的 50%），系统会将其识别为**不同的列或表单单元格**。
-   这防止了将标签（Label）与远处的数值（Value）强行合并成一行，保护了语义的独立性。

### 3.3 结果归一匹配 (Robust Backend Matching)
后端定位逻辑采用了“空格不敏感”策略：
1.  **预处理**：搜索时会将锚点文本和 OCR 库中的文本同时进行去空格/正则归一化。
2.  **序列匹配**：只要字符序列一致，无论 OCR 波动导致的空格差异如何，都能精准命中定位坐标。

---

## 4. 技术栈
-   **Frontend**: React, Intl.Segmenter (Chrome 87+/Safari 14.1+/Firefox 125+)
-   **Backend**: Python, Regex normalization, math-based overlap detection.

---

## 5. 预期收益
-   **极高鲁棒性**：无惧 OCR 识别波动或微量排版移位。
-   **原生性能**：无需加载额外繁重的分词库，利用系统级 API 秒级响应。
-   **精准搜索**：生成的锚点文本完全符合人类阅读习惯，直接支持全文检索。
